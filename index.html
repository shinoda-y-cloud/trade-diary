<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>トレード日記 (Ultimate v2)</title>
  <style>
    :root{
      --bg:#0b1020; --card:#111a33; --text:#e9eefc; --muted:#9fb0dd;
      --border:rgba(255,255,255,0.12);
      --accent:#67d3ff; --good:#49e3a2; --bad:#ff6b6b; --warn:#ffd166;
      --long:#4facfe; --short:#ff5858; --mix:#a18cd1;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:system-ui,-apple-system,sans-serif;
      background:radial-gradient(1200px 700px at 20% -10%, #17306b 0%, transparent 55%),
                 radial-gradient(900px 600px at 110% 20%, #2b145b 0%, transparent 55%),
                 var(--bg);
      color:var(--text); padding-bottom:80px;
    }

    .container { max-width:1000px; margin:0 auto; padding:0 16px; }
    header { padding:20px 0 10px; display:flex; justify-content:space-between; align-items:end; flex-wrap:wrap; gap:10px; }
    h1 { font-size:18px; margin:0; font-weight:800; letter-spacing:1px; }
    .header-btns { display:flex; gap:8px; flex-wrap:wrap; }

    .card {
      background:rgba(17,26,51,0.6);
      border:1px solid var(--border);
      box-shadow:0 12px 40px rgba(0,0,0,0.3);
      border-radius:8px; margin-bottom:16px;
      overflow:hidden;
    }
    .card-hd {
      background:rgba(255,255,255,0.03);
      padding:10px 14px; border-bottom:1px solid var(--border);
      display:flex; justify-content:space-between; align-items:center;
      font-size:12px; color:var(--muted);
    }
    .card-bd { padding:14px; }

    .form-grid { display:grid; grid-template-columns: 1fr; gap:12px; }
    @media (min-width: 600px) { .form-grid { grid-template-columns: repeat(2, 1fr); } }
    @media (min-width: 900px) { .form-grid { grid-template-columns: repeat(4, 1fr); } }

    label { display:block; font-size:11px; color:var(--muted); margin-bottom:4px; }
    select, input, textarea {
      width:100%; background:rgba(0,0,0,0.3); border:1px solid var(--border);
      color:var(--text); border-radius:4px; padding:8px; outline:none; font-size:13px;
    }
    select:focus, input:focus { border-color:var(--accent); background:rgba(0,0,0,0.5); }
    textarea { min-height:38px; height:38px; resize:vertical; }

    .col-full { grid-column: 1 / -1; }
    .col-half { grid-column: span 1; }
    @media (min-width: 600px) { .col-half { grid-column: span 2; } }

    button {
      border:none; cursor:pointer; padding:6px 12px; border-radius:4px;
      font-size:12px; font-weight:700; transition:0.2s; white-space:nowrap;
    }
    .btn-primary { background:var(--accent); color:#0b1020; }
    .btn-primary:hover { opacity:0.9; }
    .btn-sec { background:transparent; border:1px solid var(--border); color:var(--muted); }
    .btn-sec:hover { border-color:var(--text); color:var(--text); }
    .btn-danger { background:rgba(255,107,107,0.15); color:var(--bad); border:1px solid rgba(255,107,107,0.3); }
    .btn-danger:hover { background:var(--bad); color:#fff; }

    .toggle-group { display:flex; background:rgba(0,0,0,0.3); border-radius:6px; padding:2px; border:1px solid var(--border); }
    .toggle-btn { flex:1; text-align:center; padding:6px 12px; font-size:12px; border-radius:4px; cursor:pointer; color:var(--muted); }
    .toggle-btn.active { background:var(--accent); color:#0b1020; font-weight:bold; }

    .chip-group { display:flex; flex-wrap:wrap; gap:8px; }
    .chip {
      display:inline-flex; align-items:center; gap:6px;
      padding:6px 10px; border-radius:4px;
      background:rgba(255,255,255,0.05);
      border:1px solid var(--border);
      font-size:12px; cursor:pointer; user-select:none;
      white-space:nowrap; transition: all 0.2s;
    }
    .chip:hover { background:rgba(255,255,255,0.1); border-color:var(--accent); }
    .chip input { margin:0; width:auto; }
    .chip-del { margin-left:6px; color:var(--bad); font-weight:bold; padding:0 4px; cursor:pointer; }
    .chip-del:hover { background:rgba(255,107,107,0.2); border-radius:4px; }

    .kpi-row { display:grid; grid-template-columns:repeat(4,1fr); gap:10px; margin-bottom:15px; }
    .kpi-box { background:rgba(0,0,0,0.2); border-radius:6px; padding:8px; text-align:center; border:1px solid var(--border); }
    .kpi-label { font-size:10px; color:var(--muted); }
    .kpi-val { font-size:16px; font-weight:bold; color:var(--text); }
    .v-good { color:var(--good); } .v-bad { color:var(--bad); }

    .timeline { display:flex; flex-direction:column; gap:16px; }
    .t-card {
      background:rgba(17,26,51,0.6); border:1px solid var(--border);
      border-radius:8px; padding:16px; position:relative; overflow:hidden;
    }
    .t-top { display:flex; justify-content:space-between; align-items:flex-start; margin-bottom:10px; gap:10px; }
    .t-date-grp { display:flex; flex-direction:column; gap:4px; }
    .t-date { font-size:14px; font-weight:bold; color:var(--text); display:flex; align-items:center; gap:8px;}
    .t-actions { display:flex; gap:6px; }
    .t-pnl-row { display:flex; align-items:baseline; gap:12px; margin-bottom:12px; padding-bottom:12px; border-bottom:1px solid rgba(255,255,255,0.05); }
    .t-pnl { font-size:20px; font-weight:800; letter-spacing:0.5px; }
    .t-meta { display:flex; flex-wrap:wrap; gap:6px; margin-bottom:12px; }
    .badge {
      font-size:10px; padding:3px 8px; border-radius:4px;
      border:1px solid var(--border); color:var(--muted); font-weight:600;
      display:inline-flex; align-items:center; gap:4px;
    }
    .badge.long { border-color:rgba(79,172,254,0.4); color:var(--long); background:rgba(79,172,254,0.1); }
    .badge.short { border-color:rgba(255,88,88,0.4); color:var(--short); background:rgba(255,88,88,0.1); }
    .badge.mix { border-color:rgba(161,140,209,0.4); color:var(--mix); background:rgba(161,140,209,0.1); }
    .badge.cnt-ok { border-color:rgba(73,227,162,0.4); color:var(--good); }
    .badge.cnt-warn { border-color:rgba(255,209,102,0.4); color:var(--warn); }
    .badge.cnt-bad { border-color:rgba(255,107,107,0.4); color:var(--bad); }
    .badge.rank-a { border-color:var(--good); color:#0b1020; background:var(--good); }
    .badge.rank-b { border-color:var(--muted); color:var(--text); }
    .badge.rank-c { border-color:var(--bad); color:var(--bad); }
    .badge.rank-s {
      border:1px solid #ffd700;
      background: linear-gradient(135deg, #ffd700 0%, #fdb931 50%, #ffd700 100%);
      color: #5c4d00;
      box-shadow: 0 0 10px rgba(255, 215, 0, 0.4);
      text-shadow: 0 1px 0 rgba(255,255,255,0.4);
      animation: shine 3s infinite linear;
      font-weight:800; padding:3px 10px;
    }
    @keyframes shine {
      0% { background-position: 0% 50%; box-shadow: 0 0 5px rgba(255,215,0,0.3); }
      50% { background-position: 100% 50%; box-shadow: 0 0 15px rgba(255,215,0,0.7); }
      100% { background-position: 0% 50%; box-shadow: 0 0 5px rgba(255,215,0,0.3); }
    }
    .t-body {
      background:rgba(0,0,0,0.25); border-radius:6px; padding:12px;
      margin-bottom:12px; font-size:13px; line-height:1.6; color:#fff; white-space: pre-wrap;
    }
    .t-foot {
      display:grid; grid-template-columns: 1fr; gap:8px;
      font-size:11px; color:var(--muted);
    }
    @media (min-width: 600px) { .t-foot { grid-template-columns: 1fr 1fr 1fr; } }
    .t-item strong { display:block; color:var(--accent); font-size:10px; margin-bottom:2px; opacity:0.8; }

    .tbl-wrap { overflow-x:auto; }
    .tbl { width:100%; border-collapse:collapse; font-size:12px; white-space:nowrap; }
    .tbl th { text-align:left; color:var(--muted); padding:6px; border-bottom:1px solid var(--border); }
    .tbl td { padding:6px; border-bottom:1px solid rgba(255,255,255,0.05); }
    .tag { padding:2px 6px; border-radius:4px; font-size:10px; border:1px solid var(--border); }
    .tag.win { border-color:var(--good); color:var(--good); }
    .tag.lose { border-color:var(--bad); color:var(--bad); }

    .flex-center { display:flex; align-items:center; gap:8px; }
    .text-right { text-align:right; }
    .mini-text { font-size:10px; color:var(--muted); margin-top:4px; }
    .overlay { position:fixed; inset:0; background:rgba(0,0,0,0.6); display:none; justify-content:center; align-items:center; z-index:99; padding:10px;}
    .modal-box { width:min(600px, 100%); background:#0f1730; border:1px solid var(--border); border-radius:8px; padding:20px; box-shadow:0 20px 50px #000; max-height:90vh; overflow-y:auto;}
    .cfg-section { margin-bottom:20px; border-bottom:1px solid var(--border); padding-bottom:12px; }
    .cfg-list { display:flex; flex-wrap:wrap; gap:8px; margin-top:8px; }
    .cfg-add-row { display:flex; gap:8px; margin-top:8px; }

/* =========================
   DICTIONARY (CARD UI)
   ========================= */
.dict-wrap{
  display:grid;
  grid-template-columns: 280px 1fr;
  gap:12px;
}
@media (max-width: 820px){
  .dict-wrap{ grid-template-columns: 1fr; }
}
.dict-left{
  border:1px solid var(--border);
  background:rgba(0,0,0,0.18);
  border-radius:10px;
  padding:10px;
  max-height:70vh;
  overflow:auto;
}
.dict-left-hd{
  font-size:12px;
  color:var(--muted);
  font-weight:800;
  padding:6px 6px 10px;
  border-bottom:1px solid rgba(255,255,255,0.08);
  margin-bottom:10px;
}
.dict-list{ display:flex; flex-direction:column; gap:8px; }
.dict-item{
  border:1px solid rgba(255,255,255,0.10);
  background:rgba(17,26,51,0.35);
  border-radius:10px;
  padding:10px;
  cursor:pointer;
  transition:.15s;
}

    /* 並び替え（ドラッグ）用：任意 */
.dict-item{ 
  user-select:none;
}
.dict-item[draggable="true"]{
  cursor: grab;
}
.dict-item.dragging{
  opacity: .55;
}
.dict-item.drop-target{
  outline: 2px solid rgba(103,211,255,0.55);
  outline-offset: 2px;
}

.dict-item:hover{ border-color:rgba(103,211,255,0.45); background:rgba(17,26,51,0.55); }
.dict-item.active{
  border-color:rgba(103,211,255,0.75);
  box-shadow:0 0 0 2px rgba(103,211,255,0.15) inset;
}
.dict-item-t{ font-size:13px; font-weight:900; color:var(--text); }
.dict-item-s{ margin-top:4px; font-size:11px; color:var(--muted); line-height:1.45; }

.dict-actions{ display:flex; gap:8px; margin-top:10px; }

.dict-right{ max-height:70vh; overflow:auto; }
.dict-card{
  border:1px solid var(--border);
  background:rgba(17,26,51,0.40);
  border-radius:12px;
  overflow:hidden;
}
.dict-card-hd{
  display:flex;
  justify-content:space-between;
  align-items:flex-start;
  gap:10px;
  padding:12px 14px;
  border-bottom:1px solid rgba(255,255,255,0.10);
  background:rgba(255,255,255,0.03);
}
.dict-title{ font-size:16px; font-weight:1000; letter-spacing:.3px; }
.dict-card-bd{ padding:14px; }
.dict-grid{ display:grid; grid-template-columns: 1fr; gap:10px; }

.dict-sec{
  border:1px solid rgba(255,255,255,0.10);
  border-radius:12px;
  padding:10px 12px;
  background:rgba(0,0,0,0.18);
}
.dict-sec-h{
  font-size:11px;
  color:var(--accent);
  font-weight:900;
  opacity:.95;
  margin-bottom:6px;
}
.dict-sec-b{
  font-size:13px;
  line-height:1.85;
  color:#fff;

  /* 改行は普通に。変な折り返しを抑制 */
  white-space: normal;
  overflow-wrap: break-word;  /* 長い英数字だけ折る */
  word-break: normal;         /* 日本語を変な位置で割らない */
  /* line-break は好みで（不要なら消してOK） */
  /* line-break: strict; */
}

.dict-foot{
  margin-top:10px;
  border-top:1px solid rgba(255,255,255,0.08);
  padding-top:10px;
}

/* =========================
   DICTIONARY UI FIX (v2)  ※1×4 + 改行改善
   ========================= */

/* ① 辞書モーダルだけ幅を最大化 */
#lectureBg .modal-box{
  width: min(1200px, calc(100vw - 24px));
  max-height: 90vh;
}

/* ② ヘッダー（検索＋ボタン列）が詰まらないように */
#lectureBg .modal-box > div:first-child{
  flex-wrap: wrap;
  gap: 8px;
}
#lectureBg #dictSearch{
  width: min(520px, 100%);
}

/* ③ 左:一覧 / 右:カード の器を広げる */
#lectureBg .dict-wrap{
  display: grid;
  grid-template-columns: 340px minmax(0, 1fr);
  gap: 14px;
}
@media (max-width: 820px){
  #lectureBg .dict-wrap{ grid-template-columns: 1fr; }
}

/* ④ 右側：1×4（縦に4つ）に固定 */
#lectureBg .dict-grid{
  display: grid;
  grid-template-columns: 1fr;  /* 常に1列 */
  gap: 12px;
}

/* ⑤ 右側カードの余白・読みやすさ */
#lectureBg .dict-card-bd{
  padding: 16px;
}

/* ⑥ フォント/改行：段落改行を活かし、変な折返しを抑制 */
#lectureBg .dict-sec-h{
  font-size: 11px;
}
#lectureBg .dict-sec-b{
  font-size: 12.5px;
  line-height: 1.75;
  color: #fff;

  /* 改行を保持（textContent の \n をそのまま見せる） */
  white-space: pre-wrap;

  /* 長い英数字だけ適切に折る（日本語を変に割らない） */
  overflow-wrap: break-word;
  word-break: normal;
}

/* =========================
   DICT EDITOR
   ========================= */
.dict-editor{
  margin-top:12px;
  border:1px solid rgba(255,255,255,0.10);
  background:rgba(0,0,0,0.18);
  border-radius:12px;
  padding:12px;
}
.dict-editor .row{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:10px;
}
@media (max-width: 820px){
  .dict-editor .row{ grid-template-columns: 1fr; }
}
.dict-editor label{
  display:block;
  font-size:11px;
  color:var(--muted);
  margin-bottom:4px;
}
.dict-editor input, .dict-editor textarea{
  width:100%;
  background:rgba(0,0,0,0.28);
  border:1px solid var(--border);
  color:var(--text);
  border-radius:8px;
  padding:10px;
  outline:none;
  font-size:12px;
}
.dict-editor textarea{
  min-height:110px;
  resize:vertical;
  line-height:1.6;
}
.dict-editor .actions{
  display:flex;
  gap:8px;
  flex-wrap:wrap;
  margin-top:10px;
}
.dict-editor .hint{
  margin-top:8px;
  font-size:10px;
  color:var(--muted);
  opacity:.9;
}

  </style>
</head>

<body>

<div class="container">
  <header>
    <div>
      <h1>トレード日記 Ultimate</h1>
      <div style="color:red;font-weight:bold;">BUILD CHECK 2026-01-18</div>
      <div class="mini-text" id="ghLabel">GitHub: 未設定</div>
    </div>
    <div class="header-btns">
      <button class="btn-primary" id="btnCopyPrompt">📋 AI指示書</button>
      <button class="btn-sec" id="btnConfig">⚙️ 選択肢</button>
      <button class="btn-sec" id="btnGitHub">GitHub</button>
      <button class="btn-sec" id="btnBackup">バックアップ</button>
      <button class="btn-sec" id="btnRestore">復元</button>
      <button class="btn-sec" id="btnRelock">ロック</button>
      <button class="btn-sec" id="btnLecture">📘 講義ノート</button>
    </div>
  </header>

  <section class="card">
    <div class="card-hd">
      <span>📝 今日の記録 (<span id="todayLabel">-</span>)</span>
      <div class="flex-center">
        <button class="btn-sec" id="btnLoadToday" style="padding:2px 8px; font-size:10px;">読込</button>
        <button class="btn-sec" id="btnResetForm" style="padding:2px 8px; font-size:10px;">クリア</button>
      </div>
    </div>
    <div class="card-bd form-grid">
      <div>
        <label>日付</label>
        <input type="date" id="date" />
      </div>
      <div>
        <label>相場環境</label>
        <select id="marketType">
          <option value="不明">不明</option>
          <option value="トレンド">トレンド</option>
          <option value="レンジ">レンジ</option>
          <option value="荒い">荒い</option>
          <option value="薄い">薄い</option>
        </select>
      </div>
      <div>
        <label>結果</label>
        <select id="result">
          <option value="未入力">未入力</option>
          <option value="勝ち">勝ち</option>
          <option value="負け">負け</option>
          <option value="トントン">トントン</option>
          <option value="ノートレ">ノートレ</option>
        </select>
      </div>
      <div>
        <label>損益 (円)</label>
        <input type="number" id="pnl" placeholder="例: -13070" />
      </div>

      <div>
        <label>エントリー回数</label>
        <input type="number" id="trades" placeholder="回数 (例: 5)" />
      </div>
      <div>
        <label>方向感</label>
        <select id="bias">
          <option value="不明">不明</option>
          <option value="ロング">ロング</option>
          <option value="ショート">ショート</option>
          <option value="両方ダメ">両方ダメ</option>
        </select>
      </div>
      <div>
        <label>負け主因</label>
        <select id="lossCause"></select>
      </div>
      <div>
        <label>守れたルール</label>
        <select id="keptRule"></select>
      </div>

      <div>
        <label>自己評価</label>
        <select id="grade">
          <option value="未入力">未入力</option>
          <option value="S">S (完璧)</option>
          <option value="A">A (良い)</option>
          <option value="B">B (普通)</option>
          <option value="C">C (悪い)</option>
        </select>
      </div>
      <div>
        <label>明日のアクション</label>
        <select id="nextAction"></select>
      </div>

      <div class="col-half">
        <label>主戦銘柄</label>
        <div class="chip-group" id="coreTickers"></div>
        <input type="text" id="extraTickers" placeholder="その他 (例: 9101 商船三井)" style="margin-top:6px;" />
      </div>

      <div class="col-full">
        <label>一言メモ (日記)</label>
        <textarea id="memo" placeholder="ここに反省や感情を詳しく書く..."></textarea>
      </div>

      <div class="col-full" style="display:flex; gap:10px; margin-top:4px;">
        <button class="btn-primary" id="btnSave" style="flex:1;">保存 (ローカル)</button>
        <button class="btn-sec" id="btnExportCsv">CSV</button>
        <button class="btn-danger" id="btnClearAll">全削除</button>
      </div>
      <div class="col-full mini-text" id="autoHint">自動バックアップ: OFF</div>
    </div>
  </section>

  <section class="card">
    <div class="card-hd">
      <span>📊 ダッシュボード (<span id="countLabel">0</span>件)</span>
    </div>
    <div class="card-bd">
      <div class="kpi-row">
        <div class="kpi-box">
          <div class="kpi-label">今月損益</div>
          <div class="kpi-val" id="kpiMonthPnl">0</div>
        </div>
        <div class="kpi-box">
          <div class="kpi-label">勝率</div>
          <div class="kpi-val" id="kpiWinRate">-</div>
        </div>
        <div class="kpi-box">
          <div class="kpi-label">ノートレ率</div>
          <div class="kpi-val" id="kpiNoTrade">-</div>
        </div>
        <div class="kpi-box">
          <div class="kpi-label">最多敗因</div>
          <div class="kpi-val" id="kpiTopCause" style="font-size:12px;">-</div>
        </div>
      </div>

      <hr style="border:0; border-top:1px solid var(--border); margin:20px 0;">

      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
        <span style="font-size:12px; color:var(--muted); font-weight:bold;">過去の記録</span>
        <div class="toggle-group">
          <div class="toggle-btn active" id="viewCard">📰 タイムライン</div>
          <div class="toggle-btn" id="viewTable">📑 リスト</div>
        </div>
      </div>

      <div id="viewContainerCard" class="timeline"></div>

      <div id="viewContainerTable" class="tbl-wrap" style="display:none;">
        <table class="tbl">
          <thead>
            <tr>
              <th style="width:80px;">日付</th>
              <th style="width:50px;">結果</th>
              <th style="width:70px; text-align:right;">損益</th>
              <th style="padding-left:12px;">要約</th>
              <th style="width:60px; text-align:right;">操作</th>
            </tr>
          </thead>
          <tbody id="rows"></tbody>
        </table>
      </div>
    </div>
  </section>
</div>

<!-- 🔒 ロック -->
<div class="overlay" id="lockBg" style="display:none;">
  <div class="modal-box" style="text-align:center;">
    <h3>🔒 パスコードロック</h3>
    <input type="password" id="lockPass" placeholder="パスコードを入力" style="margin:16px 0; text-align:center; font-size:16px;" />
    <button class="btn-primary" id="btnUnlock" style="width:100%;">解除</button>
    <div class="mini-text" style="color:var(--bad); display:none; margin-top:8px;" id="lockErr">パスコードが違います</div>
  </div>
</div>

<!-- ⚙️ 選択肢 -->
<div class="overlay" id="configBg">
  <div class="modal-box">
    <div style="display:flex; justify-content:space-between; margin-bottom:16px;">
      <h3 style="margin:0;">選択肢の編集</h3>
      <button class="btn-sec" id="btnCloseConfig" style="padding:2px 8px;">閉じる</button>
    </div>
    <div id="cfgContainer"></div>
    <div class="mini-text">※ 変更は自動保存されます。</div>
  </div>
</div>

<!-- GitHub設定 -->
<div class="overlay" id="modalBg">
  <div class="modal-box">
    <div style="display:flex; justify-content:space-between; margin-bottom:12px;">
      <h3 style="margin:0;">GitHub設定</h3>
      <button class="btn-sec" id="btnCloseModal" style="padding:2px 8px;">閉じる</button>
    </div>
    <div class="mini-text" id="ghStatus" style="margin-bottom:12px;">状態: 未設定</div>
    <div class="form-grid">
      <div><label>Owner</label><input id="ghOwner" placeholder="user" /></div>
      <div><label>Repo</label><input id="ghRepo" placeholder="repo" /></div>
      <div><label>Branch</label><input id="ghBranch" placeholder="main" /></div>
      <div><label>Path</label><input id="ghPath" placeholder="data/diary.json" /></div>
      <div class="col-full"><label>Token (PAT)</label><input id="ghToken" type="password" /></div>
      <div class="col-full">
        <label>自動バックアップ</label>
        <select id="autoMode">
          <option value="off">OFF</option>
          <option value="onsave">保存時に実行 (推奨)</option>
          <option value="interval">定期実行 (15分)</option>
        </select>
        <input type="hidden" id="autoMinutes" value="15">
      </div>
      <div class="col-full" style="display:flex; gap:10px; margin-top:8px;">
        <button class="btn-primary" id="btnSaveGh" style="flex:1;">保存</button>
        <button class="btn-sec" id="btnTest">接続テスト</button>
        <button class="btn-danger" id="btnClearGh">解除</button>
      </div>
    </div>
  </div>
</div>

<!-- 📘 辞書カード（旧：講義ノート） -->
<div class="overlay" id="lectureBg">
  <div class="modal-box">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
      <h3 style="margin:0;">📚 トレード辞書（カード）</h3>
      <div style="display:flex; gap:8px; align-items:center;">
        <input id="dictSearch" placeholder="検索（例：水平線 / VWAP）"
               style="width:240px; background:rgba(0,0,0,0.25); border:1px solid var(--border); color:var(--text);
                      border-radius:6px; padding:8px; outline:none; font-size:12px;" />
        <button class="btn-sec" id="btnLectureReset" style="padding:2px 8px;">初期に戻す</button>
        <button class="btn-sec" id="btnCloseLecture" style="padding:2px 8px;">閉じる</button>
      </div>
    </div>

    <div class="mini-text" style="margin-bottom:10px;">
      ※ 辞書カードはローカル保存（ブラウザ内）。「初期に戻す」は辞書カードを初期状態へ戻します。
    </div>

    <div class="dict-wrap">
      <div class="dict-left">
        <div class="dict-left-hd">カード一覧</div>
        <div id="dictList" class="dict-list"></div>

<div class="dict-actions">
  <button class="btn-sec" id="btnLectureCopy" style="flex:1;">このカードをコピー</button>
  <button class="btn-primary" id="btnDictEdit" style="flex:1;">編集</button>
  <button class="btn-sec" id="btnDictNew" style="flex:1;">＋新規</button>
</div>


        <div class="mini-text" style="opacity:.8; margin-top:8px;">
          ※ まずは《水平線》を完成形に固定し、次に他カードを追加していきます。
        </div>
      </div>

      <div class="dict-right">
        <div class="dict-card">
          <div class="dict-card-hd">
            <div>
              <div id="dictTitle" class="dict-title">-</div>
              <div id="dictMeta" class="mini-text" style="margin-top:4px; opacity:.9;">-</div>
            </div>
            <div style="display:flex; gap:8px;">
              <button class="btn-sec" id="btnDictPrev" title="前のカード">←</button>
              <button class="btn-sec" id="btnDictNext" title="次のカード">→</button>
            </div>
          </div>

          <div class="dict-card-bd">
            <div class="dict-grid">
              <div class="dict-sec">
                <div class="dict-sec-h">① 概念（何のための線か）</div>
                <div id="dictConcept" class="dict-sec-b">-</div>
              </div>

              <div class="dict-sec">
                <div class="dict-sec-h">② 引く場所（時間足 × 優先度）</div>
                <div id="dictWhere" class="dict-sec-b">-</div>
              </div>

              <div class="dict-sec">
                <div class="dict-sec-h">③ 実戦判断（買う／売る／見送る）</div>
                <div id="dictAction" class="dict-sec-b">-</div>
              </div>

              <div class="dict-sec">
                <div class="dict-sec-h">④ NG例（負けパターン）</div>
                <div id="dictNg" class="dict-sec-b">-</div>
              </div>
            </div>

            <div class="dict-foot">
              <div class="mini-text" style="opacity:.9;">
                ※ ルールは「長文を読む」ためではなく「ザラ場で3秒で判断」するためにあります。
              </div>
            </div>
          </div>
        </div>

        <div id="lectureSavedHint" class="mini-text" style="display:none; margin-top:10px; color:var(--good);">
          保存しました。
        </div>
      </div>
    </div>
  </div>
</div>


<script>
document.addEventListener("DOMContentLoaded", () => {
  // =========================
  // MASTER DATA & CONFIG
  // =========================
  const OPT_KEY = "tradeDiary_options";
  const DEFAULTS = {
    lossCause: ["なし", "逆張り癖", "地合い悪", "ブレイクダマシ", "利確が早い", "損切りが遅い", "エントリーが早い", "ロットが重い", "集中できない"],
    keptRule: ["損切りを徹底", "ロット抑制", "迷ったら見送り", "1銘柄集中", "エントリー待てた", "後場エントリーしない"],
    nextAction: ["地合いを見て目線を切り替える", "寄り15分は触らない", "VWAP付近は見送り", "ブレイクは2本確定後", "1日1銘柄に絞る", "ノートレも正解とする"],
    // ※ここは「元に戻す」目的で、まずは過去の形を維持（後で編集可能）
    coreTickers: ["8031 三井物産", "9503 関西電力", "5020 ENEOS", "3099 三越伊勢丹", "7011 三菱重工", "6501 日立", "9501 東京電力", "5406 神戸製鋼"]
  };
  let userOpts = JSON.parse(localStorage.getItem(OPT_KEY)||"null") || JSON.parse(JSON.stringify(DEFAULTS));

  function $(id){return document.getElementById(id);}

  function saveUserOpts(){
    localStorage.setItem(OPT_KEY, JSON.stringify(userOpts));
    renderSelects();
  }

  function renderSelects(){
    const fill = (id, list) => {
      const el = $(id);
      if(!el) return;
      el.innerHTML = '<option value="未入力">未入力</option>';
      list.forEach(v => {
        const op=document.createElement("option");
        op.value=v; op.textContent=v;
        el.appendChild(op);
      });
    };
    fill("lossCause", userOpts.lossCause);
    fill("keptRule", userOpts.keptRule);
    fill("nextAction", userOpts.nextAction);

    const tc = $("coreTickers");
    tc.innerHTML = "";
    userOpts.coreTickers.forEach(t => {
      const lbl = document.createElement("label");
      lbl.className = "chip";
      lbl.innerHTML = `<input type="checkbox" value="${t}">${(t.split(" ")[1]||t)}`;
      tc.appendChild(lbl);
    });
  }

  // Generate Prompt
  $("btnCopyPrompt").onclick = () => {
    const opts = userOpts;
    const txt = `
あなたは私の専属トレードコーチ『先生』です。
本日の私たちのトレード会話履歴と、以下の『トレード日記』の仕様に基づき、今日の日記入力用データを生成してください。

【出力要件】
- 各項目に対し、会話内容から最も適切なものを選んでください。
- 該当するものがない場合は新たな選択肢を作成してください。
- 「一言メモ」は、会話の流れから私の感情や反省点、先生のアドバイスを要約して、簡潔かつ具体的に記述してください。
- 出力はコピペしやすい形式（Markdownのリストやテーブル、または項目: 値 の形式）でお願いします。

【現在の日記項目の仕様】
■ 基本情報
- 日付: YYYY/MM/DD
- 相場タイプ: 不明 / トレンド / レンジ / 荒い / 薄い
- 結果: 勝ち / 負け / トントン / ノートレ
- 損益: 数値 (円)
- エントリー回数: 数値 (回)
- 方向感: 不明 / ロング / ショート / 両方ダメ / 未入力

■ 選択肢リスト（※ここから最も近いものを選んでください）
- 負け主因: [${opts.lossCause.join(", ")}]
- 守れたルール: [${opts.keptRule.join(", ")}]
- 明日のアクション: [${opts.nextAction.join(", ")}]
- 主戦銘柄: [${opts.coreTickers.join(", ")}] ※これ以外の場合はコード+名称で記述

■ 評価
- 自己評価: S (完璧) / A (良い) / B (普通) / C (悪い)
`.trim();
    navigator.clipboard.writeText(txt).then(()=>alert("AI指示書をコピーしました！\nチャットに貼り付けてください。"));
  };

  // Config UI
  const cfgBg=$("configBg"), cfgCont=$("cfgContainer");
  function renderConfigUI(){
    cfgCont.innerHTML = "";
    [{k:"lossCause",t:"負け主因"},{k:"keptRule",t:"守れたルール"},{k:"nextAction",t:"明日のアクション"},{k:"coreTickers",t:"主戦銘柄"}]
      .forEach(sec => {
        const div=document.createElement("div"); div.className="cfg-section";
        const tit=document.createElement("div"); tit.style.fontWeight="bold"; tit.style.marginBottom="6px"; tit.textContent=sec.t; div.appendChild(tit);

        const row=document.createElement("div"); row.className="cfg-add-row";
        const inp=document.createElement("input"); inp.placeholder="追加...";
        const btn=document.createElement("button"); btn.className="btn-primary"; btn.textContent="追加";
        btn.onclick=()=>{
          const v=inp.value.trim();
          if(v && !userOpts[sec.k].includes(v)){
            userOpts[sec.k].push(v);
            saveUserOpts();
            renderConfigUI();
          }
        };
        row.appendChild(inp); row.appendChild(btn); div.appendChild(row);

        const list=document.createElement("div"); list.className="cfg-list";
        userOpts[sec.k].forEach(item => {
          const chip=document.createElement("span"); chip.className="chip";
          chip.innerHTML=`${item} <span class="chip-del" data-k="${sec.k}" data-v="${item}">×</span>`;
          list.appendChild(chip);
        });
        div.appendChild(list); cfgCont.appendChild(div);
      });

    // delete handlers
    cfgCont.querySelectorAll(".chip-del").forEach(el=>{
      el.addEventListener("click", ()=>{
        const k = el.getAttribute("data-k");
        const v = el.getAttribute("data-v");
        if(confirm(`「${v}」を削除しますか？`)){
          userOpts[k]=userOpts[k].filter(x=>x!==v);
          saveUserOpts();
          renderConfigUI();
        }
      });
    });
  }
  $("btnConfig").onclick=()=>{ renderConfigUI(); cfgBg.style.display="flex"; };
  $("btnCloseConfig").onclick=()=>{ cfgBg.style.display="none"; };

  // =========================
  // CORE LOGIC
  // =========================
  const PASSCODE = "kyoto.3594"; const UNLOCK_KEY = "tradeDiary_unlocked_v1";
  const KEY = "tradeDiary_v1"; const GHKEY = "tradeDiary_github";

  const lockBg=$("lockBg"), lockPass=$("lockPass");
  function isUnlocked(){ return localStorage.getItem(UNLOCK_KEY)==="1"; }
  function showLock(){ lockBg.style.display="flex"; lockPass.value=""; setTimeout(()=>lockPass.focus(),50); }
  function unlock(){
    if(lockPass.value.trim()===PASSCODE){
      localStorage.setItem(UNLOCK_KEY,"1");
      lockBg.style.display="none";
    } else {
      $("lockErr").style.display="block";
    }
  }
  $("btnUnlock").onclick=unlock;
  $("btnRelock").onclick=()=>{ localStorage.removeItem(UNLOCK_KEY); showLock(); };
  lockPass.onkeydown=(e)=>{if(e.key==="Enter")unlock();};
  if(!isUnlocked()) showLock(); else lockBg.style.display="none";

  const els={
    date:$("date"), marketType:$("marketType"), result:$("result"), pnl:$("pnl"),
    trades:$("trades"), bias:$("bias"), lossCause:$("lossCause"), keptRule:$("keptRule"),
    grade:$("grade"), nextAction:$("nextAction"), memo:$("memo"), extraTickers:$("extraTickers")
  };
  const ui={ todayLabel:$("todayLabel"), countLabel:$("countLabel"), rows:$("rows"), cardView:$("viewContainerCard") };
  const todayISO=()=>{ const d=new Date(); return new Date(d.getTime()-d.getTimezoneOffset()*60000).toISOString().slice(0,10); };

  function loadAll(){ try{return JSON.parse(localStorage.getItem(KEY)||"[]");}catch{return[];} }
  function saveAll(d){ localStorage.setItem(KEY,JSON.stringify(d)); }

  function fmtYen(n){ if(!Number.isFinite(n))return"-"; return (n>0?"+":"")+n.toLocaleString(); }

  const getCore=()=>Array.from(document.querySelectorAll("#coreTickers input:checked")).map(e=>e.value);
  const setCore=(vals)=>{
    const s=new Set(vals||[]);
    document.querySelectorAll("#coreTickers input").forEach(e=>e.checked=s.has(e.value));
  };

  function formToEntry(){
    return {
      date:els.date.value||todayISO(),
      marketType:els.marketType.value,
      result:els.result.value,
      pnl:els.pnl.value===""?null:Number(els.pnl.value),
      tickers:[...getCore(), ...(els.extraTickers.value||"").split(",").map(s=>s.trim()).filter(Boolean)],
      trades:els.trades.value,
      bias:els.bias.value,
      lossCause:els.lossCause.value,
      keptRule:els.keptRule.value,
      grade:els.grade.value,
      nextAction:els.nextAction.value,
      memo:(els.memo.value||"").trim(),
      updatedAt:new Date().toISOString()
    };
  }
  function entryToForm(e){
    els.date.value=e.date||todayISO();
    els.marketType.value=e.marketType||"不明";
    els.result.value=e.result||"未入力";
    els.pnl.value=Number.isFinite(e.pnl)?e.pnl:"";

    const ts=e.tickers||[];
    setCore(ts);
    els.extraTickers.value=ts.filter(t=>!userOpts.coreTickers.includes(t)).join(",");

    els.trades.value=e.trades||"";
    els.bias.value=e.bias||"不明";
    els.lossCause.value=e.lossCause||"未入力";
    els.keptRule.value=e.keptRule||"未入力";
    els.grade.value=e.grade||"未入力";
    els.nextAction.value=e.nextAction||"未入力";
    els.memo.value=e.memo||"";
  }

  let viewMode = "card";
  $("viewCard").onclick = () => {
    viewMode="card"; render();
    $("viewCard").className="toggle-btn active";
    $("viewTable").className="toggle-btn";
    $("viewContainerCard").style.display="flex";
    $("viewContainerTable").style.display="none";
  };
  $("viewTable").onclick = () => {
    viewMode="table"; render();
    $("viewTable").className="toggle-btn active";
    $("viewCard").className="toggle-btn";
    $("viewContainerCard").style.display="none";
    $("viewContainerTable").style.display="block";
  };

  function render(){
    const all=loadAll();
    ui.countLabel.textContent=all.length;
    ui.todayLabel.textContent=els.date.value||todayISO();

    const ym=new Date().toISOString().slice(0,7);
    const m=all.filter(x=>(x.date||"").startsWith(ym));
    const pnl=m.reduce((a,x)=>a+(x.pnl||0),0);
    $("kpiMonthPnl").textContent=fmtYen(pnl);
    $("kpiMonthPnl").className="kpi-val "+(pnl>0?"v-good":(pnl<0?"v-bad":""));

    const w=m.filter(x=>x.result==="勝ち").length, l=m.filter(x=>x.result==="負け").length;
    $("kpiWinRate").textContent=(w+l)>0?Math.round(w/(w+l)*100)+"%":"-";

    const nt=m.filter(x=>x.result==="ノートレ").length;
    $("kpiNoTrade").textContent=m.length>0?Math.round(nt/m.length*100)+"%":"-";

    const counts={};
    m.forEach(x=>{ if(x.lossCause&&x.lossCause!=="未入力") counts[x.lossCause]=(counts[x.lossCause]||0)+1; });
    let top="-", max=0;
    for(let k in counts) if(counts[k]>max){max=counts[k];top=k;}
    $("kpiTopCause").textContent=top;

    const sorted = all.slice().reverse();

    if(viewMode === "table"){
      ui.rows.innerHTML="";
      sorted.forEach(e=>{
        const tr=document.createElement("tr");
        const tag=e.result==="勝ち"?"win":(e.result==="負け"?"lose":"");
        const pnlC=e.pnl>0?"v-good":(e.pnl<0?"v-bad":"");
        tr.innerHTML=`<td>${e.date}</td>
          <td><span class="tag ${tag}">${e.result}</span></td>
          <td class="text-right ${pnlC}">${fmtYen(e.pnl)}</td>
          <td style="padding-left:12px; color:var(--muted); overflow:hidden; text-overflow:ellipsis; max-width:200px;">${e.lossCause} | ${e.memo}</td>
          <td class="text-right"><button class="btn-sec" style="padding:2px 6px;" onclick="loadEntry('${e.date}')">✎</button></td>`;
        ui.rows.appendChild(tr);
      });
    } else {
      ui.cardView.innerHTML = "";
      sorted.forEach(e=>{
        const div = document.createElement("div"); div.className="t-card";
        const resTag = e.result==="勝ち"?"win":(e.result==="負け"?"lose":"");
        const pnlC = e.pnl>0?"v-good":(e.pnl<0?"v-bad":"");

        let biasCls = "";
        if((e.bias||"").includes("ロング")) biasCls="long";
        else if((e.bias||"").includes("ショート")) biasCls="short";
        else if((e.bias||"").includes("両方")) biasCls="mix";

        let cntCls = "cnt-ok";
        const tNum = Number(e.trades);
        if(tNum >= 3) cntCls="cnt-warn";
        if(tNum >= 6) cntCls="cnt-bad";

        let rankCls = "";
        if(e.grade==="S") rankCls="rank-s";
        else if(e.grade==="A") rankCls="rank-a";
        else if(e.grade==="B") rankCls="rank-b";
        else if(e.grade==="C") rankCls="rank-c";

        let pills = [];
        if((e.tickers||[]).length) pills.push(`<span class="badge">${e.tickers.map(t=>t.split(" ")[1]||t).join("/")}</span>`);
        if(e.bias!=="不明" && e.bias!=="未入力") pills.push(`<span class="badge ${biasCls}">${e.bias}</span>`);
        if(e.trades) pills.push(`<span class="badge ${cntCls}">${e.trades}回</span>`);
        if(e.grade!=="未入力") pills.push(`<span class="badge ${rankCls}">評価:${e.grade}</span>`);

        div.innerHTML = `
          <div class="t-top">
            <div class="t-date-grp">
              <div class="t-date">${e.date} <span class="tag ${resTag}">${e.result}</span></div>
            </div>
            <div class="t-actions">
              <button class="btn-sec" style="font-size:10px; padding:4px 8px;" onclick="loadEntry('${e.date}')">編集</button>
              <button class="btn-danger" style="font-size:10px; padding:4px 8px;" onclick="delEntry('${e.date}')">削除</button>
            </div>
          </div>
          <div class="t-pnl-row"><span class="t-pnl ${pnlC}">${fmtYen(e.pnl)}</span></div>
          <div class="t-meta">${pills.join("")}</div>
          <div class="t-body">${(e.memo||"").replace(/\n/g, "<br>")}</div>
          <div class="t-foot">
            <div class="t-item"><strong>⚠️ 敗因</strong>${e.lossCause}</div>
            <div class="t-item"><strong>✅ 守ったルール</strong>${e.keptRule}</div>
            <div class="t-item"><strong>🚀 明日</strong>${e.nextAction}</div>
          </div>`;
        ui.cardView.appendChild(div);
      });
    }

    updateGhLabel();
  }

  window.loadEntry=(d)=>{
    const f=loadAll().find(x=>x.date===d);
    if(f){ entryToForm(f); window.scrollTo(0,0);
    }
  };

  window.delEntry=(d)=>{
    if(!confirm(`${d} の記録を削除しますか？`)) return;
    const all=loadAll().filter(x=>x.date!==d);
    saveAll(all);
    render();
  };

  // =========================
  // FORM BUTTONS
  // =========================
  function resetFormToToday(){
    els.date.value=todayISO();
    els.marketType.value="不明";
    els.result.value="未入力";
    els.pnl.value="";
    els.trades.value="";
    els.bias.value="不明";
    els.lossCause.value="未入力";
    els.keptRule.value="未入力";
    els.grade.value="未入力";
    els.nextAction.value="未入力";
    els.memo.value="";
    els.extraTickers.value="";
    setCore([]);
    ui.todayLabel.textContent=els.date.value;
  }

  $("btnResetForm").onclick = ()=>{ resetFormToToday(); };
  $("btnLoadToday").onclick = ()=>{
    const d = els.date.value || todayISO();
    const f = loadAll().find(x=>x.date===d);
    if(f){ entryToForm(f); alert(`読込しました: ${d}`); }
    else { alert(`この日付のデータは見つかりません: ${d}`); }
  };

  $("btnSave").onclick=()=>{
    const e=formToEntry();
    if(!e.date){ alert("日付が空です"); return; }

    const all=loadAll();
    const idx=all.findIndex(x=>x.date===e.date);

    if(idx>=0){
      // updatedAt比較で、複数端末の衝突をなるべく避ける（ローカルなので軽め）
      const old=all[idx];
      const oldAt = old.updatedAt ? Date.parse(old.updatedAt) : 0;
      const newAt = e.updatedAt ? Date.parse(e.updatedAt) : Date.now();
      if(newAt >= oldAt){
        all[idx]=e;
      }else{
        // 念のため
        all[idx]=e;
      }
    }else{
      all.push(e);
    }
    // 日付昇順に並べる（表示はreverseで新しい順）
    all.sort((a,b)=>(a.date||"").localeCompare(b.date||""));

    saveAll(all);
    render();
    alert("保存しました（ローカル）");

    // auto backup
    const gh = loadGh();
    if(gh.autoMode === "onsave"){
      backupToGitHub().catch(()=>{});
    }
  };

  $("btnClearAll").onclick=()=>{
    if(!confirm("全データを削除します。よろしいですか？")) return;
    localStorage.removeItem(KEY);
    render();
    alert("全データ削除しました");
  };

  $("btnExportCsv").onclick=()=>{
    const all=loadAll();
    if(!all.length){ alert("データがありません"); return; }
    const header=[
      "date","marketType","result","pnl","trades","bias","lossCause","keptRule","grade","nextAction","tickers","memo","updatedAt"
    ];
    const rows=[header.join(",")].concat(all.map(e=>{
      const esc=(v)=>{
        const s = (v===null||v===undefined) ? "" : String(v);
        const t = s.replace(/"/g,'""');
        return `"${t}"`;
      };
      return [
        e.date,e.marketType,e.result,e.pnl,e.trades,e.bias,e.lossCause,e.keptRule,e.grade,e.nextAction,
        (e.tickers||[]).join("/"), (e.memo||""), (e.updatedAt||"")
      ].map(esc).join(",");
    }));
    const blob=new Blob([rows.join("\n")],{type:"text/csv;charset=utf-8"});
    const url=URL.createObjectURL(blob);
    const a=document.createElement("a");
    a.href=url;
    a.download=`trade-diary_${todayISO()}.csv`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };


  // =========================
  // DICTIONARY (CARD UI)
  // =========================
  const DICT_KEY = "tradeDiary_dict_v1";

  const DEFAULT_DICT = [
    {
      // =========================
      // 水平線
      // =========================
      id: "horizontal-line",
      title: "水平線（レジサポ）",
      summary: "最優先。全員が見ている“共通の壁”を作る。",
      tags: ["水平線", "レジサポ", "日足", "1時間足"],
      updatedAt: "2026-01-18",
      concept:
`【役割】
・“皆が意識する価格”を特定し、無駄な売買（ノイズ）を減らす。
・デイトレでは「入る場所」よりも「入ってはいけない場所」を明確化する。`,
      where:
`【優先度A：必須（まずここだけ）】
・前日高値／前日安値
・日足・1時間足の目立つ高値／安値（直近中心）
・キリ番（例：2500 / 5000）

【足の使い分け】
・引く：日足・1時間足（信頼）
・刺す：5分足（実行）
※ 5分足だけで引いた線は“ノイズ化”しやすい。`,
      action:
`【買う（ロング）】
・下→上に超えて「定着」後の押し（抵抗→支持転換）
・水平線付近で反発した“事実”（ヒゲ反発・出来高増）を確認してから

【売る（ショート）】
・上→下に割って「定着」後の戻り（支持→抵抗転換）
・水平線付近で上値が止められた“事実”を確認してから

【見送る（最重要）】
・攻防中（水平線ど真ん中）は触らない
・乖離が大きい初動は追わない（押し／戻り待ち）`,
      ng:
`【典型NG】
・反発“するはず”で先回り（事実がない）
・線を増やしすぎて判断が遅れる
・上位足の線を無視して5分足だけで戦う（ダマシ率↑）`
    },

    // =========================
    // 並行チャネル
    // =========================
    {
      id:"parallel-channel",
      title:"並行チャネル",
      summary:"（次に作成）",
      tags:["チャネル"],
      updatedAt:"2026-01-18",
      concept:
`【役割】
・トレンドを「幅」で捉え、押し目/戻りの“ゾーン”を可視化する。
・水平線が点（価格）なら、チャネルは面（帯）。
・上手く機能すると「下限で買う／上限で売る／抜けたら撤退」が明確になる。

【前提】
・トレンドが斜めに進行している（水平レンジでは効きにくい）
・波が比較的素直（ヒゲだらけの乱高下だと機能低下）`,

      where:
`【引き方（最小手数）】
① まず“基準線”：
・上昇：安値同士を2点以上で結ぶ（上昇トレンドライン）
・下降：高値同士を2点以上で結ぶ（下降トレンドライン）

② 次に“平行コピー”：
・上昇：基準線を、直近高値（山）に当てて平行移動 → 上限ライン
・下降：基準線を、直近安値（谷）に当てて平行移動 → 下限ライン

【足の優先度】
・引く：15分/5分（形が見える方）
・刺す：1分（エントリーの詰め）
※ 1分だけでチャネル作るとノイズ化。`,

      action:
`【買う（ロング）】
・上昇チャネルの下限付近で反発の“事実”
・理想：下限→反発→VWAP回復→押し目成立
・利確：中央値（ミドル）or 上限タッチまで（地合い次第）
・損切り：下限を明確に割って“定着”したら撤退（即）

【売る（ショート）】
・下降チャネルの上限付近で失速の“事実”
・理想：上限→失速→VWAP割れ→戻り売り成立
・利確：中央値 or 下限タッチまで
・損切り：上限を上抜け“定着”で撤退（即）

【ブレイク時（重要）】
・チャネル抜け＝押し/戻りの前提崩壊
・抜け方向に“追う”のではなく、一旦「定着→戻り/押し待ち」`,

      ng:
`【典型NG】
・引けるまで点を探してチャネルを“捏造”する
・チャネル内のど真ん中で触る（期待値が薄い）
・抜けたのに「戻るはず」で粘る（損切り遅れ）
・上位足の水平線を無視して、チャネルだけを信じる`
    },

    // =========================
    // フィボナッチ
    // =========================
    {
      id:"fibonacci",
      title:"フィボナッチ（使う場面限定）",
      summary:"（次に作成）",
      tags:["フィボナッチ"],
      updatedAt:"2026-01-18",
      concept:
`【役割（使いどころ限定）】
・「押し/戻りの“目安”」を数値化する補助線。
・水平線（レジサポ）より優先度は下。主役にはしない。
・効くのは「トレンドが出ていて、押し/戻りが素直に出る局面」だけ。

【前提】
・方向（上昇 or 下降）が明確
・直近の波（スイング高値↔安値）が誰の目にも分かる
・レンジ/乱高下/材料で飛ぶ局面では期待値が落ちる。`,

      where:
`【引く場所（最重要：波の選び方）】
・上昇：押し目候補を探す →「安値（起点）→高値（終点）」で引く
・下降：戻り売り候補を探す →「高値（起点）→安値（終点）」で引く

【対象の波】
・優先：15分足/5分足の“直近トレンド波”
・NG：1分足の細波、ギザギザの波、都合のいい波の選択

【見る帯（目安）】
・0.382 / 0.5 / 0.618（ここだけ）
※ レベルを増やすほど判断が遅れる。`,

      action:
`【買う（ロング）に使う場面】
・上昇トレンド中、押しで 0.382〜0.618 に到達
・到達後に「反発の事実」が出たらエントリー候補
　例：下ヒゲ反発／出来高増／直近安値を割らない／VWAP回復 など
・損切り：起点安値（or 0.618割れで撤退）※事前に固定

【売る（ショート）に使う場面】
・下降トレンド中、戻りで 0.382〜0.618 に到達
・到達後に「上値抑えの事実」が出たら候補
　例：上ヒゲ／出来高増で失速／VWAPに戻れず反落 など
・損切り：起点高値（or 0.618上抜けで撤退）※事前に固定

【見送る（最重要）】
・水平線ど真ん中、VWAPど真ん中（攻防中）は見送る
・波が不明瞭なら引かない（＝使わない）`,

      ng:
`【典型NG（負け筋）】
・レンジでフィボを当てに行く（当たるまで引き直す）
・“都合のいい波”を選んで正当化する
・レベルを増やしすぎて、線の森で動けなくなる
・0.618到達だけで先回り（反発/失速の事実なし）
・損切りを「起点」ではなく“気分”でズラす（破綻）`
    }
  ];

  function loadDict(){
    try{
      const raw = localStorage.getItem(DICT_KEY);
      if(!raw) return DEFAULT_DICT.slice();
      const arr = JSON.parse(raw);
      return Array.isArray(arr) ? arr : DEFAULT_DICT.slice();
    }catch{
      return DEFAULT_DICT.slice();
    }
  }
  function saveDict(arr){
    localStorage.setItem(DICT_KEY, JSON.stringify(arr || []));
  }

  let dict = loadDict();
  let dictIndex = 0;

  const lectureBg = $("lectureBg");
  const dictList = $("dictList");
  const dictTitle = $("dictTitle");
  const dictMeta = $("dictMeta");
  const dictConcept = $("dictConcept");
  const dictWhere = $("dictWhere");
  const dictAction = $("dictAction");
  const dictNg = $("dictNg");
  const dictSearch = $("dictSearch");
  const lectureSavedHint = $("lectureSavedHint");

  function currentCard(){
    return dict[dictIndex] || dict[0] || DEFAULT_DICT[0];
  }

  // -------------------------
  // Web editor state
  // -------------------------
  let editorOpen = false;

  function ensureEditor(){
    const right = document.querySelector("#lectureBg .dict-right");
    if(!right) return;

    if(document.getElementById("dictEditor")) return;

    const wrap = document.createElement("div");
    wrap.className = "dict-editor";
    wrap.id = "dictEditor";
    wrap.style.display = "none";
    wrap.innerHTML = `
      <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; margin-bottom:10px;">
        <div style="font-weight:900; font-size:12px; color:var(--text);">カード編集</div>
        <button class="btn-sec" id="btnDictCloseEdit" style="padding:2px 8px;">閉じる</button>
      </div>

      <div class="row">
        <div>
          <label>タイトル</label>
          <input id="edTitle" placeholder="例：フィボナッチ（使う場面限定）">
        </div>
        <div>
          <label>要約（一覧に出る短文）</label>
          <input id="edSummary" placeholder="例：補助線。水平線が薄い時だけ使う。">
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <div>
          <label>タグ（カンマ区切り）</label>
          <input id="edTags" placeholder="例：フィボナッチ, 押し目, 戻り">
        </div>
        <div>
          <label>ID（英数字/ハイフン 推奨）</label>
          <input id="edId" placeholder="例：fibonacci">
        </div>
      </div>

      <div style="margin-top:10px;">
        <label>① 概念</label>
        <textarea id="edConcept" placeholder="・改行OK（そのまま表示します）"></textarea>
      </div>
      <div style="margin-top:10px;">
        <label>② 引く場所</label>
        <textarea id="edWhere"></textarea>
      </div>
      <div style="margin-top:10px;">
        <label>③ 実戦判断</label>
        <textarea id="edAction"></textarea>
      </div>
      <div style="margin-top:10px;">
        <label>④ NG例</label>
        <textarea id="edNg"></textarea>
      </div>

      <div class="actions">
        <button class="btn-primary" id="btnDictSave">保存（ローカル）</button>
        <button class="btn-sec" id="btnDictDuplicate">複製</button>
        <button class="btn-danger" id="btnDictDelete">削除</button>
        <button class="btn-sec" id="btnDictExport">JSON書き出し</button>
        <button class="btn-sec" id="btnDictImport">JSON取り込み</button>
        <input type="file" id="dictImportFile" accept="application/json" style="display:none;">
      </div>

      <div class="hint">
        ・保存先は localStorage（ブラウザ内）です。<br>
        ・IDはユニーク推奨。空なら自動生成します。<br>
        ・JSON書き出しでバックアップできます。
      </div>
    `;

    right.appendChild(wrap);

    // close
    document.getElementById("btnDictCloseEdit").onclick = () => toggleEditor(false);

    // export
    document.getElementById("btnDictExport").onclick = () => {
      const payload = JSON.stringify(loadDict(), null, 2);
      const blob = new Blob([payload], {type:"application/json"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `trade-dict_${todayISO()}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    };

    // import
    document.getElementById("btnDictImport").onclick = () => {
      document.getElementById("dictImportFile").click();
    };
    document.getElementById("dictImportFile").addEventListener("change", async (e)=>{
      const f = e.target.files && e.target.files[0];
      if(!f) return;
      try{
        const text = await f.text();
        const json = JSON.parse(text);
        if(!Array.isArray(json)) throw new Error("配列JSONではありません");
        saveDict(json);
        dict = loadDict();
        dictIndex = 0;
        renderCard();
        renderDictList();
        alert("取り込み完了（ローカル）");
      }catch(err){
        alert("取り込み失敗: " + (err.message||err));
      }finally{
        e.target.value = "";
      }
    });

    // save
    document.getElementById("btnDictSave").onclick = () => {
      const cur = currentCard();
      const idRaw = (document.getElementById("edId").value||"").trim();
      const id = idRaw || (cur?.id) || ("card-" + Date.now());

      const card = {
        id,
        title: (document.getElementById("edTitle").value||"").trim() || "（無題）",
        summary: (document.getElementById("edSummary").value||"").trim(),
        tags: (document.getElementById("edTags").value||"").split(",").map(s=>s.trim()).filter(Boolean),
        updatedAt: todayISO(),
        concept: (document.getElementById("edConcept").value||"").trim(),
        where: (document.getElementById("edWhere").value||"").trim(),
        action: (document.getElementById("edAction").value||"").trim(),
        ng: (document.getElementById("edNg").value||"").trim()
      };

      let arr = loadDict();
      const idx = arr.findIndex(x=>x.id===id);
      if(idx>=0) arr[idx]=card;
      else arr.push(card);

      saveDict(arr);
      dict = loadDict();

      const realIdx = dict.findIndex(x=>x.id===id);
      if(realIdx>=0) dictIndex = realIdx;

      renderCard();
      renderDictList();
      alert("保存しました（ローカル）");
    };

    // duplicate
    document.getElementById("btnDictDuplicate").onclick = () => {
      const cur = currentCard();
      if(!cur) return;
      const base = {...cur};
      base.id = (cur.id||"card") + "-copy-" + Date.now();
      base.title = (cur.title||"") + "（コピー）";
      base.updatedAt = todayISO();
      const arr = loadDict();
      arr.push(base);
      saveDict(arr);
      dict = loadDict();
      dictIndex = dict.findIndex(x=>x.id===base.id);
      renderCard(); renderDictList();
      fillEditorFromCurrent();
      alert("複製しました");
    };

    // delete
    document.getElementById("btnDictDelete").onclick = () => {
      const cur = currentCard();
      if(!cur?.id) return;
      if(!confirm(`削除しますか？\n${cur.title}\n(${cur.id})`)) return;
      const arr = loadDict().filter(x=>x.id!==cur.id);
      saveDict(arr);
      dict = loadDict();
      dictIndex = Math.max(0, Math.min(dictIndex, dict.length-1));
      renderCard(); renderDictList();
      fillEditorFromCurrent();
      alert("削除しました");
    };
  }

  function fillEditorFromCurrent(){
    ensureEditor();
    const c = currentCard() || {};
    const $v = (id)=>document.getElementById(id);

    $v("edTitle").value   = c.title || "";
    $v("edSummary").value = c.summary || "";
    $v("edTags").value    = (c.tags||[]).join(", ");
    $v("edId").value      = c.id || "";
    $v("edConcept").value = c.concept || "";
    $v("edWhere").value   = c.where || "";
    $v("edAction").value  = c.action || "";
    $v("edNg").value      = c.ng || "";
  }

  function toggleEditor(on){
    ensureEditor();
    const ed = document.getElementById("dictEditor");
    if(!ed) return;
    editorOpen = (on===undefined) ? !editorOpen : !!on;
    ed.style.display = editorOpen ? "block" : "none";
    if(editorOpen) fillEditorFromCurrent();
  }

  function bindEditorButtons(){
    const bEdit = document.getElementById("btnDictEdit");
    const bNew  = document.getElementById("btnDictNew");
    if(bEdit) bEdit.onclick = ()=>toggleEditor(true);

    if(bNew) bNew.onclick = ()=>{
      ensureEditor();
      toggleEditor(true);

      // clear for new card
      document.getElementById("edTitle").value="";
      document.getElementById("edSummary").value="";
      document.getElementById("edTags").value="";
      document.getElementById("edId").value="";
      document.getElementById("edConcept").value="";
      document.getElementById("edWhere").value="";
      document.getElementById("edAction").value="";
      document.getElementById("edNg").value="";
      document.getElementById("edTitle").focus();
    };
  }

  function renderCard(){
    const c = currentCard();
    dictTitle.textContent = c.title || "-";
    const tags = (c.tags||[]).map(t=>`#${t}`).join(" ");
    dictMeta.textContent = `更新: ${c.updatedAt||"-"}　${tags}`;
    dictConcept.textContent = c.concept || "-";
    dictWhere.textContent = c.where || "-";
    dictAction.textContent = c.action || "-";
    dictNg.textContent = c.ng || "-";

    // editor follows current selection
    if(editorOpen) fillEditorFromCurrent();
  }

  function filteredDict(){
    const q = (dictSearch?.value || "").trim().toLowerCase();
    if(!q) return dict;
    return dict.filter(c=>{
      const hay = `${c.title||""} ${(c.tags||[]).join(" ")} ${c.summary||""}`.toLowerCase();
      return hay.includes(q);
    });
  }

  function renderDictList(){
    const list = filteredDict();
    dictList.innerHTML = "";

    const isSearching = ((dictSearch?.value || "").trim().length > 0);

    list.forEach((c)=>{
      const item = document.createElement("div");
      item.className = "dict-item" + (c.id === currentCard().id ? " active" : "");
      item.innerHTML = `<div class="dict-item-t">${c.title||"-"}</div><div class="dict-item-s">${c.summary||""}</div>`;

      // 検索中は並び替えしない（フィルタ結果で並べ替えると事故るため）
      item.draggable = !isSearching;
      item.dataset.id = c.id;

      item.onclick = ()=>{
        const realIdx = dict.findIndex(x=>x.id === c.id);
        if(realIdx >= 0){
          dictIndex = realIdx;
          renderCard();
          renderDictList();
        }
      };

      dictList.appendChild(item);
    });

    // 検索中は注記（任意）
    if(isSearching){
      const note = document.createElement("div");
      note.className = "mini-text";
      note.style.opacity = ".8";
      note.style.marginTop = "10px";
      note.textContent = "※ 検索中は並び替えできません（検索を消すとドラッグ可能）";
      dictList.appendChild(note);
    }
  }

    // =========================
  // DICT SORT (Drag & Drop)  ※左の一覧だけ
  // =========================
  let dragId = null;

  function reorderDictById(fromId, toId){
    if(!fromId || !toId || fromId === toId) return;

    const fromIdx = dict.findIndex(x=>x.id === fromId);
    const toIdx   = dict.findIndex(x=>x.id === toId);
    if(fromIdx < 0 || toIdx < 0) return;

    const [moved] = dict.splice(fromIdx, 1);
    dict.splice(toIdx, 0, moved);

    // 並び替えを永続化
    saveDict(dict);

    // 選択中カードのインデックスを追従
    const cur = currentCard();
    const newIdx = dict.findIndex(x=>x.id === (cur?.id));
    if(newIdx >= 0) dictIndex = newIdx;
  }

  // イベントはコンテナでまとめて拾う
  dictList.addEventListener("dragstart", (e)=>{
    const el = e.target.closest(".dict-item");
    if(!el || !el.draggable) return;
    dragId = el.dataset.id;
    el.classList.add("dragging");
    e.dataTransfer.effectAllowed = "move";
  });

  dictList.addEventListener("dragend", (e)=>{
    const el = e.target.closest(".dict-item");
    if(el) el.classList.remove("dragging");
    dragId = null;
    dictList.querySelectorAll(".dict-item.drop-target").forEach(x=>x.classList.remove("drop-target"));
  });

  dictList.addEventListener("dragover", (e)=>{
    const over = e.target.closest(".dict-item");
    if(!over || !over.draggable) return;
    e.preventDefault(); // drop許可
    dictList.querySelectorAll(".dict-item.drop-target").forEach(x=>x.classList.remove("drop-target"));
    over.classList.add("drop-target");
    e.dataTransfer.dropEffect = "move";
  });

  dictList.addEventListener("drop", (e)=>{
    const over = e.target.closest(".dict-item");
    if(!over || !over.draggable) return;
    e.preventDefault();

    const toId = over.dataset.id;
    reorderDictById(dragId, toId);

    // 再描画（左リストだけ更新）
    renderDictList();
  });


  function openLecture(){
    dict = loadDict();
    const hIdx = dict.findIndex(x=>x.id==="horizontal-line");
    if(hIdx >= 0) dictIndex = hIdx;

    renderCard();
    renderDictList();

    if(lectureSavedHint) lectureSavedHint.style.display = "none";
    lectureBg.style.display = "flex";

    // bind editor buttons after modal is available
    bindEditorButtons();
    ensureEditor();

    setTimeout(()=>dictSearch?.focus(), 50);
  }

  function closeLecture(){
    lectureBg.style.display = "none";
    // editor stays in DOM; state can remain
  }

  $("btnLecture").onclick = openLecture;
  $("btnCloseLecture").onclick = closeLecture;

  $("btnDictPrev").onclick = ()=>{
    dictIndex = Math.max(0, dictIndex - 1);
    renderCard();
    renderDictList();
  };

  $("btnDictNext").onclick = ()=>{
    dictIndex = Math.min(dict.length - 1, dictIndex + 1);
    renderCard();
    renderDictList();
  };

  if(dictSearch){
    dictSearch.addEventListener("input", ()=>{
      renderDictList();
    });
  }

  $("btnLectureReset").onclick = () => {
    if(confirm("辞書カードを初期状態に戻しますか？（ローカルの辞書データを初期化）")){
      dict = DEFAULT_DICT.slice();
      saveDict(dict);
      dictIndex = 0;
      renderCard();
      renderDictList();
      if(lectureSavedHint){
        lectureSavedHint.style.display = "block";
        setTimeout(()=>lectureSavedHint.style.display="none", 1200);
      }
    }
  };

  $("btnLectureCopy").onclick = async () => {
    const c = currentCard();
    const out =
`# ${c.title}

## ① 概念
${c.concept}

## ② 引く場所（時間足 × 優先度）
${c.where}

## ③ 実戦判断（買う／売る／見送る）
${c.action}

## ④ NG例（負けパターン）
${c.ng}
`.trim();
    await navigator.clipboard.writeText(out);
    alert("このカードをコピーしました。");
  };

  lectureBg.addEventListener("click", (e)=>{
    if(e.target === lectureBg) closeLecture();
  });
  

  // =========================
  // GITHUB STORAGE
  // =========================
  const modalBg=$("modalBg");
  const ghLabel=$("ghLabel");

  function loadGh(){
    try{
      return JSON.parse(localStorage.getItem(GHKEY)||"{}");
    }catch{
      return {};
    }
  }
  function saveGh(obj){
    localStorage.setItem(GHKEY, JSON.stringify(obj||{}));
    updateGhLabel();
  }

  function updateGhLabel(){
    const gh=loadGh();
    if(gh.owner && gh.repo){
      ghLabel.textContent=`GitHub: ${gh.owner}/${gh.repo}@${gh.branch||"main"} (${gh.path||"data/diary.json"})`;
      $("ghStatus").textContent=`状態: 設定済み`;
      $("ghStatus").style.color="var(--good)";
    }else{
      ghLabel.textContent="GitHub: 未設定";
      $("ghStatus").textContent="状態: 未設定";
      $("ghStatus").style.color="var(--muted)";
    }
    $("autoHint").textContent = `自動バックアップ: ${ (gh.autoMode||"off").toUpperCase() }`;
  }

  // open github modal
  $("btnGitHub").onclick=()=>{
    const gh=loadGh();
    $("ghOwner").value=gh.owner||"";
    $("ghRepo").value=gh.repo||"";
    $("ghBranch").value=gh.branch||"main";
    $("ghPath").value=gh.path||"data/diary.json";
    $("ghToken").value=gh.token||"";
    $("autoMode").value=gh.autoMode||"off";
    $("ghStatus").textContent = (gh.owner&&gh.repo) ? "状態: 設定済み" : "状態: 未設定";
    modalBg.style.display="flex";
  };
  $("btnCloseModal").onclick=()=>{ modalBg.style.display="none"; };

  $("btnSaveGh").onclick=()=>{
    const gh={
      owner:$("ghOwner").value.trim(),
      repo:$("ghRepo").value.trim(),
      branch:$("ghBranch").value.trim()||"main",
      path:$("ghPath").value.trim()||"data/diary.json",
      token:$("ghToken").value.trim(),
      autoMode:$("autoMode").value
    };
    if(!gh.owner || !gh.repo || !gh.branch || !gh.path || !gh.token){
      alert("Owner/Repo/Branch/Path/Token は必須です");
      return;
    }
    saveGh(gh);
    alert("GitHub設定を保存しました");
    modalBg.style.display="none";
  };

  $("btnClearGh").onclick=()=>{
    if(!confirm("GitHub設定を解除しますか？")) return;
    localStorage.removeItem(GHKEY);
    updateGhLabel();
    alert("解除しました");
    modalBg.style.display="none";
  };

  // --- GitHub API helpers ---
  async function ghFetch(url, gh, opts={}){
    const headers = Object.assign({
      "Accept":"application/vnd.github+json",
      "Authorization":`Bearer ${gh.token}`,
      "X-GitHub-Api-Version":"2022-11-28"
    }, opts.headers||{});
    const res = await fetch(url, {...opts, headers});
    if(!res.ok){
      const txt = await res.text().catch(()=>"(no body)");
      throw new Error(`GitHub API error ${res.status}: ${txt.slice(0,200)}`);
    }
    return res;
  }

  async function getRemoteFile(gh){
    // GET /repos/{owner}/{repo}/contents/{path}?ref={branch}
    const url = `https://api.github.com/repos/${encodeURIComponent(gh.owner)}/${encodeURIComponent(gh.repo)}/contents/${gh.path}?ref=${encodeURIComponent(gh.branch)}`;
    const res = await ghFetch(url, gh, {method:"GET"});
    return await res.json();
  }

  async function putRemoteFile(gh, contentText, message){
    // PUT /repos/{owner}/{repo}/contents/{path}
    const url = `https://api.github.com/repos/${encodeURIComponent(gh.owner)}/${encodeURIComponent(gh.repo)}/contents/${gh.path}`;
    let sha = null;

    // try to read existing sha (file may not exist yet)
    try{
      const remote = await getRemoteFile(gh);
      sha = remote && remote.sha ? remote.sha : null;
    }catch(e){
      // file not found is ok; but GitHub returns 404 which would have thrown.
      // We'll just create new file.
      sha = null;
    }

    const body = {
      message: message || `update diary ${todayISO()}`,
      content: btoa(unescape(encodeURIComponent(contentText))),
      branch: gh.branch
    };
    if(sha) body.sha = sha;

    const res = await ghFetch(url, gh, {method:"PUT", body: JSON.stringify(body)});
    return await res.json();
  }

  function withToast(promise, okMsg, ngMsg){
    return promise.then(()=>{
      if(okMsg) alert(okMsg);
    }).catch((e)=>{
      console.error(e);
      alert((ngMsg||"エラーが発生しました") + "\n\n" + String(e.message||e));
      throw e;
    });
  }

  // =========================
  // BACKUP / RESTORE
  // =========================
  async function backupToGitHub(){
    const gh = loadGh();
    if(!gh.owner || !gh.repo || !gh.token){
      alert("GitHub設定が未設定です（GitHubボタンから設定してください）");
      return;
    }
    const all = loadAll();
    const payload = JSON.stringify({
      meta:{
        app:"trade-diary-ultimate",
        version:"v2",
        exportedAt:new Date().toISOString(),
        count:all.length
      },
      data: all
    }, null, 2);

    $("btnBackup").textContent="バックアップ中...";
    $("btnBackup").disabled=true;

    try{
      await putRemoteFile(gh, payload, `backup diary ${todayISO()}`);
      $("btnBackup").textContent="バックアップ";
      $("btnBackup").disabled=false;
      alert("バックアップ完了（GitHub）");
    }catch(e){
      $("btnBackup").textContent="バックアップ";
      $("btnBackup").disabled=false;
      throw e;
    }
  }

  async function restoreFromGitHub(){
    const gh = loadGh();
    if(!gh.owner || !gh.repo || !gh.token){
      alert("GitHub設定が未設定です（GitHubボタンから設定してください）");
      return;
    }
    $("btnRestore").textContent="復元中...";
    $("btnRestore").disabled=true;

    try{
      const remote = await getRemoteFile(gh);
      if(!remote || !remote.content){
        throw new Error("リモートファイルが空です");
      }
      const text = decodeURIComponent(escape(atob(remote.content.replace(/\n/g,""))));
      const json = JSON.parse(text);

      // 旧形式: 配列だけ / 新形式: {data:[]}
      const arr = Array.isArray(json) ? json : (Array.isArray(json.data) ? json.data : []);
      if(!Array.isArray(arr)) throw new Error("復元データ形式が不正です");

      // merge: dateキーで updatedAt が新しい方を採用
      const local = loadAll();
      const map = new Map();
      local.forEach(x=>map.set(x.date, x));
      arr.forEach(x=>{
        if(!x || !x.date) return;
        const cur = map.get(x.date);
        if(!cur){ map.set(x.date, x); return; }
        const curAt = cur.updatedAt ? Date.parse(cur.updatedAt) : 0;
        const xAt   = x.updatedAt ? Date.parse(x.updatedAt) : 0;
        if(xAt >= curAt) map.set(x.date, x);
      });
      const merged = Array.from(map.values()).sort((a,b)=>(a.date||"").localeCompare(b.date||""));

      saveAll(merged);
      render();

      $("btnRestore").textContent="復元";
      $("btnRestore").disabled=false;
      alert(`復元完了（GitHub）: ${merged.length}件`);
    }catch(e){
      $("btnRestore").textContent="復元";
      $("btnRestore").disabled=false;
      throw e;
    }
  }

  $("btnBackup").onclick=()=>withToast(backupToGitHub(), null, "バックアップ失敗");
  $("btnRestore").onclick=()=>{
    if(!confirm("GitHubから復元します。ローカルとマージしますがよろしいですか？")) return;
    withToast(restoreFromGitHub(), null, "復元失敗");
  };

  // =========================
  // TEST CONNECTION
  // =========================
  $("btnTest").onclick=()=>{
    const gh={
      owner:$("ghOwner").value.trim(),
      repo:$("ghRepo").value.trim(),
      branch:$("ghBranch").value.trim()||"main",
      path:$("ghPath").value.trim()||"data/diary.json",
      token:$("ghToken").value.trim()
    };
    if(!gh.owner || !gh.repo || !gh.token){
      alert("Owner/Repo/Token を入力してください");
      return;
    }
    withToast(
      (async()=>{
        // simple repo check
        const url = `https://api.github.com/repos/${encodeURIComponent(gh.owner)}/${encodeURIComponent(gh.repo)}`;
        await ghFetch(url, gh, {method:"GET"});
      })(),
      "接続OK",
      "接続NG"
    );
  };

  // =========================
  // AUTO BACKUP (interval)
  // =========================
  let autoTimer = null;

  function startAutoIfNeeded(){
    const gh = loadGh();
    const mode = gh.autoMode || "off";

    if(autoTimer){ clearInterval(autoTimer); autoTimer=null; }

    if(mode==="interval"){
      autoTimer = setInterval(()=>{
        backupToGitHub().catch((e)=>{
          // ここで「Network connection lost...」的な連発を避ける
          console.warn("auto backup failed", e);
        });
      }, 15*60*1000);
    }
  }

  // =========================
  // INIT
  // =========================
  renderSelects();
  els.date.value = todayISO();
  ui.todayLabel.textContent = els.date.value;
  updateGhLabel();
  startAutoIfNeeded();
  render();

  // autoMode 変更時にタイマー更新（設定を保存してから有効化）
  $("autoMode").addEventListener("change", ()=>{
    // モーダル内で変えても、保存ボタン押すまで反映しない設計
  });

  // モーダル閉じた後にタイマー再評価
  const _oldSaveGh = $("btnSaveGh").onclick;
  $("btnSaveGh").onclick = ()=>{
    // 既存処理実行
    const gh={
      owner:$("ghOwner").value.trim(),
      repo:$("ghRepo").value.trim(),
      branch:$("ghBranch").value.trim()||"main",
      path:$("ghPath").value.trim()||"data/diary.json",
      token:$("ghToken").value.trim(),
      autoMode:$("autoMode").value
    };
    if(!gh.owner || !gh.repo || !gh.branch || !gh.path || !gh.token){
      alert("Owner/Repo/Branch/Path/Token は必須です");
      return;
    }
    saveGh(gh);
    startAutoIfNeeded();
    alert("GitHub設定を保存しました");
    modalBg.style.display="none";
  };

});
</script>

</body>
</html>
